local main_enabled = ui.new_checkbox("Enable Main Script")

ui.label("--- Aimbot ---")
local aimbot_enabled = ui.new_checkbox("Enable Aimbot")
local aimbot_key = ui.keybind("Aimbot Key")
local aimbot_mode = ui.new_combo("Aimbot Mode", {"Slippery", "Default"})
local aimbot_fov = ui.slider_int("Aimbot FOV", 150, 10, 500, "%d")
local dynamic_aimbot_fov_enabled = ui.new_checkbox("Enable Dynamic Aimbot FOV")
local aimbot_smoothing = ui.slider_float("Aimbot Smoothing", 8.0, 1.0, 20.0, "%.1f")
local aimbot_target_bone = ui.new_combo("Aimbot Target", {"Head", "Torso"})
local aimbot_target_method = ui.new_combo("Aimbot Method", {"From Center", "From Cursor"})
local aimbot_draw_fov = ui.new_checkbox("Draw FOV")

ui.label("--- ESP ---")
local skeleton_esp_enabled = ui.new_checkbox("Enable Skeleton ESP")
local skeleton_health_based = ui.new_checkbox("Health-based Color")
local skeleton_color_picker = ui.colorpicker("Skeleton Color", 1.0, 1.0, 1.0, 1.0)
local skeleton_outline_enabled = ui.new_checkbox("Enable Skeleton Outline")
local skeleton_outline_color_picker = ui.colorpicker("Skeleton Outline Color", 0.0, 0.0, 0.0, 1.0)
local skeleton_outline_thickness_slider = ui.slider_int("Skeleton Outline Thickness", 3, 1, 5, "%d")

local function sub_vec2(v1, v2) return Vector2(v1.x - v2.x, v1.y - v2.y) end
local function len_vec2(v) return math.sqrt(v.x * v.x + v.y * v.y) end
local function div_vec2_scalar(v, s) if s == 0 then return Vector2(0, 0) end return Vector2(v.x / s, v.y / s) end
local function round(n) return n >= 0 and math.floor(n + 0.5) or math.ceil(n - 0.5) end

local function is_on_screen(screen_pos, screen_size, margin)
    margin = margin or 50
    return screen_pos.x >= -margin and screen_pos.x <= screen_size.x + margin and
           screen_pos.y >= -margin and screen_pos.y <= screen_size.y + margin
end

local cached_npcs = {}
local last_full_scan_time = 0
local locked_target = nil

local function update_npc_cache()
    local characters_folder = globals.workspace():FindChild("Characters")
    if not characters_folder then return end

    local current_npcs = {}
    local connections = {{"Head","Torso"},{"Torso","HumanoidRootPart"},{"Torso","Left Arm"},{"Torso","Right Arm"},{"HumanoidRootPart","Left Leg"},{"HumanoidRootPart","Right Leg"}}

    for _, npc_model in ipairs(characters_folder:Children()) do
        if npc_model:ClassName() == "Model" and npc_model:FindChild("AI") then
            local humanoid = npc_model:FindChild("Humanoid")
            if humanoid and humanoid:Health() > 0 then
                local parts = {}
                local all_parts_found = true
                for _, pair in ipairs(connections) do
                    for _, part_name in ipairs(pair) do
                        if not parts[part_name] then
                            local found_part = npc_model:FindChild(part_name)
                            if found_part then
                                parts[part_name] = found_part
                            else
                                all_parts_found = false
                                break
                            end
                        end
                    end
                    if not all_parts_found then break end
                end
                
                if all_parts_found then
                    current_npcs[npc_model] = {humanoid = humanoid, parts = parts}
                end
            end
        end
    end
    cached_npcs = current_npcs
end

local function draw_skeleton(npc_parts, color, outline_color, outline_thickness, skeleton_outline_enabled_val)
    local connections = {{"Head","Torso"},{"Torso","HumanoidRootPart"},{"Torso","Left Arm"},{"Torso","Right Arm"},{"HumanoidRootPart","Left Leg"},{"HumanoidRootPart","Right Leg"}}
    local screen_size = render.screen_size()

    for _, pair in ipairs(connections) do
        local part1 = npc_parts[pair[1]]
        local part2 = npc_parts[pair[2]]
        if part1 and part2 then
            local prim1 = part1:Primitive()
            local prim2 = part2:Primitive()
            if prim1 and prim2 then
                local p1_3d = prim1:GetPartPosition()
                local p2_3d = prim2:GetPartPosition()
                
                if p1_3d and p2_3d then
                    local p1_2d = utils.world_to_screen(p1_3d)
                    local p2_2d = utils.world_to_screen(p2_3d)
                    
                    if p1_2d and p2_2d and is_on_screen(p1_2d, screen_size) and is_on_screen(p2_2d, screen_size) then
                        if skeleton_outline_enabled_val then
                            render.line(p1_2d.x, p1_2d.y, p2_2d.x, p2_2d.y, outline_color.r, outline_color.g, outline_color.b, outline_color.a, outline_thickness)
                        end
                        render.line(p1_2d.x, p1_2d.y, p2_2d.x, p2_2d.y, color.r, color.g, color.b, color.a, 1)
                    end
                end
            end
        end
    end
end

local function run_aimbot(valid_npcs)
    local base_fov_from_ui = aimbot_fov:get()
    local screen_size = render.screen_size()
    local screen_center = Vector2(screen_size.x / 2, screen_size.y / 2)

    local actual_fov_for_aimbot = base_fov_from_ui
    if dynamic_aimbot_fov_enabled:get() then
        local current_camera_fov = camera.GetFov()
        local reference_unzoomed_fov = 70.0
        local scaling_factor = reference_unzoomed_fov / current_camera_fov
        actual_fov_for_aimbot = base_fov_from_ui * scaling_factor
        actual_fov_for_aimbot = math.min(actual_fov_for_aimbot, base_fov_from_ui * 2)
        actual_fov_for_aimbot = math.max(10, actual_fov_for_aimbot)
    end

    local check_origin_2d = aimbot_target_method:get() == 0 and screen_center or input.cursor_position()
    if not check_origin_2d then check_origin_2d = screen_center end

    if aimbot_draw_fov:get() then
        render.circle_outline(check_origin_2d.x, check_origin_2d.y, actual_fov_for_aimbot, 255, 255, 255, 100, 1, 64)
    end

    if not (aimbot_enabled:get() and aimbot_key:get()) then
        locked_target = nil
        return
    end

    local is_target_still_valid = false
    if locked_target then
        for _, npc_data in ipairs(valid_npcs) do
            if npc_data == locked_target then
                is_target_still_valid = true
                break
            end
        end
    end
    if not is_target_still_valid then locked_target = nil end

    if not locked_target then
        local closest_dist = math.huge
        local target_bone_names = {"Head", "Torso"}
        local selected_bone_name = target_bone_names[aimbot_target_bone:get() + 1]

        for _, npc_data in ipairs(valid_npcs) do
            local target_part = npc_data.parts[selected_bone_name] or npc_data.parts["HumanoidRootPart"]
            if target_part then
                local prim = target_part:Primitive()
                if prim then
                    local bone_pos_3d = prim:GetPartPosition()
                    if bone_pos_3d then
                        local bone_pos_2d = utils.world_to_screen(bone_pos_3d)
                        if bone_pos_2d then
                            local dist_from_check_point = len_vec2(sub_vec2(bone_pos_2d, check_origin_2d))
                            if dist_from_check_point < actual_fov_for_aimbot and dist_from_check_point < closest_dist then
                                closest_dist = dist_from_check_point
                                locked_target = npc_data
                            end
                        end
                    end
                end
            end
        end
    end

    if locked_target then
        local target_bone_names = {"Head", "Torso"}
        local selected_bone_name = target_bone_names[aimbot_target_bone:get() + 1]
        local target_part = locked_target.parts[selected_bone_name] or locked_target.parts["HumanoidRootPart"]
        if target_part then
            local prim = target_part:Primitive()
            if prim then
                local bone_pos_3d = prim:GetPartPosition()
                if bone_pos_3d then
                    local target_pos_2d = utils.world_to_screen(bone_pos_3d)
                    if target_pos_2d then
                        local dist_to_target_from_check_origin = len_vec2(sub_vec2(target_pos_2d, check_origin_2d))
                        if aimbot_mode:get() == 0 and dist_to_target_from_check_origin > actual_fov_for_aimbot then
                            locked_target = nil
                            return
                        end
                        
                        local cursor_pos = input.cursor_position()
                        if not cursor_pos then return end
                        
                        local smoothing = aimbot_smoothing:get()
                        local move_delta_vec = sub_vec2(target_pos_2d, cursor_pos)
                        local move_delta = div_vec2_scalar(move_delta_vec, smoothing)
                        
                        input.move(round(move_delta.x), round(move_delta.y))
                    else
                        locked_target = nil
                    end
                end
            end
        end
    end
end

cheat.set_callback("paint", function()
    if not main_enabled:get() then return end

    if globals.curtime() - last_full_scan_time > 1.0 then
        update_npc_cache()
        last_full_scan_time = globals.curtime()
    end

    local valid_npcs_this_frame = {}
    for _, npc_data in pairs(cached_npcs) do
        if npc_data.humanoid and npc_data.humanoid:Health() > 0 then
            local hrp = npc_data.parts["HumanoidRootPart"]
            if hrp and hrp:Primitive() then
                 local hrp_pos = hrp:Primitive():GetPartPosition()
                 if hrp_pos and utils.world_to_screen(hrp_pos) then
                    table.insert(valid_npcs_this_frame, npc_data)
                 end
            end
        end
    end

    run_aimbot(valid_npcs_this_frame)

    if skeleton_esp_enabled:get() then
        local skeleton_color = skeleton_color_picker:get()
        local skeleton_outline_color = skeleton_outline_color_picker:get()
        local skeleton_outline_thickness = skeleton_outline_thickness_slider:get()
        local skeleton_outline_enabled_val = skeleton_outline_enabled:get()

        for _, npc_data in ipairs(valid_npcs_this_frame) do
            local color_rgba
            if skeleton_health_based:get() then
                local health_percent = npc_data.humanoid:Health() / npc_data.humanoid:MaxHealth()
                color_rgba = {r = math.floor(255 * (1 - health_percent)), g = math.floor(255 * health_percent), b = 0, a = 255}
            else
                color_rgba = {r = math.floor(skeleton_color.r * 255), g = math.floor(skeleton_color.g * 255), b = math.floor(skeleton_color.b * 255), a = math.floor(skeleton_color.a * 255)}
            end

            if color_rgba then
                draw_skeleton(npc_data.parts, color_rgba, 
                              {r = math.floor(skeleton_outline_color.r * 255), g = math.floor(skeleton_outline_color.g * 255), b = math.floor(skeleton_outline_color.b * 255), a = math.floor(skeleton_outline_color.a * 255)},
                              skeleton_outline_thickness,
                              skeleton_outline_enabled_val)
            end
        end
    end
end)
